; "bitvec" is a term of type "sort"
; (declare BitVec sort)
(declare BitVec (!n mpz sort))

; bit type
(declare bit type)
(declare b0 bit)
(declare b1 bit)

; bit vector type used for constants
(declare bv type)
(declare bvn bv)
(declare bvc (! b bit (! v bv bv)))

; calculate the length of a bitvector
(program bv_len ((v bv)) mpz 
  (match v
    (bvn 0)
    ((bvc b v') (mp_add (bv_len v') 1))))

; a bv constant term
(declare a_bv
	 (! n mpz
	 (! v bv
	    (term (BitVec n)))))
	 

; a bv variable
(declare var_bv type)
; a bv variable term
(declare a_var_bv
	 (! n mpz
	 (! v var_bv
	    (term (BitVec n)))))

; bit vector binary operators
(define bvop2
	(! n mpz
	(! x (term (BitVec n)) 
        (! y (term (BitVec n))
             	   (term (BitVec n))))))

(declare bvand bvop2)
(declare bvor bvop2)
(declare bvor bvop2)
(declare bvxor bvop2)
(declare bvnand bvop2)
(declare bvnor bvop2)
(declare bvxnor bvop2)
(declare bvcomp bvop2)
(declare bvmul bvop2)
(declare bvadd bvop2)
(declare bvsub bvop2)
(declare bvudiv bvop2)
(declare bvurem bvop2)
(declare bvsdiv bvop2)
(declare bvsrem bvop2)
(declare bvsmod bvop2)
(declare bvshl bvop2)
(declare bvlshr bvop2)
(declare bvashr bvop2)
(declare concat bvop2)

; bit vector unary operators
(define bvop1
	(! n mpz
	(! x (term (BitVec n)) 
             	   (term (BitVec n)))))


(declare bvneg bvop1)
(declare bvnot bvop1)
(declare rotate_left  bvop1)
(declare rotate_right bvop1)


; bit vector parametrized operators
;; TODO side conditions for result bitwidth
;; (define bvopp
;; 	(! n mpz
;; 	(! i mpz
;; 	(! x (term (BitVec n)) 
;;               	   (term BitVec))))

;; (declare repeat bvopp)
;; (declare zero_extend bvopp)
;; (declare sign_extend bvopp)

;; ; bit vector parametrized operator with 2 arguments
;; (define bvopp2 (! i mpz
;; 	       (! j mpz
;; 	       (! x (term BitVec) 
;;                     (term BitVec)))))
		    
;; (declare extract bvopp2)

;; (define extract
;; 	(! n mpz
;; 	(! i mpz
;; 	(! j mpz
;; 	(! t (term (BitVec n))
;; 	(! m mpz
;; 	(! s (^ (mpz_sub j i) m)
;; 	   (term (BitVec m)))))))))
	   
; bit vector predicates
(define bvpred
	(! n mpz
	(! x (term (BitVec n))
	(! y (term (BitVec n))
	           formula))))
		   
(declare bvult bvpred)
(declare bvule bvpred)
(declare bvugt bvpred)
(declare bvuge bvpred)
(declare bvslt bvpred)
(declare bvsle bvpred)
(declare bvsgt bvpred)
(declare bvsge bvpred)


; all bit-vector terms are mapped with "bv_term" to:
;  - a simply-typed term of type "var_bv", which is necessary for bit-blasting
;  - a integer size
; (declare bv_term (! x (term BitVec) (! y var_bv (! n mpz type))))

;; (declare decl_bv_term_var (! n mpz    ; must be specified
;;                           (! x var_bv
;;                           (! p (! u (bv_term (a_var_bv x) x n)
;;                                  (holds cln))
;;                              (holds cln)))))

;; (declare decl_bv_term_const (! n mpz
;;                             (! v bv
;;                             (! s (^ (bv_len v) n)
;;                             (! p (! w var_bv
;;                                  (! u (bv_term (a_bv v) w n)
;;                                    (holds cln)))
;; 			      (holds cln))))))


; other terms here?


; bit blasted terms as list of formulas
(declare bblt type)
(declare bbltn bblt)
(declare bbltc (! f formula (! v bblt bblt)))

; calculate the length of a bit-blasted term
(program bblt_len ((v bblt)) mpz 
  (match v
    (bbltn 0)
    ((bbltc b v') (mp_add (bblt_len v') 1))))


; (bblast_term x y) means term y corresponds to bit level interpretation x
(declare bblast_term
	 (! n mpz
	 (! x (term (BitVec n))
	 (! y bblt
	    type))))

(declare decl_bblast
	 (! n mpz
	 (! b bblt
	 (! t (term (BitVec n))
	 (! bb (bblast_term n t b)
	 (! s (^ (bblt_len b) n)
	 (! u (! v (bblast_term n t b) (holds cln))
		   (holds cln))))))))


; a predicate to represent the n^th bit of a bitvector term
(declare bitof
	 (! x var_bv
	 (! n mpz formula)))

; bit blast  constant
(program bblast_const ((v bv) (n mpz)) bblt
  (mp_ifneg n (match v (bvn bbltn) 
                       (default (fail bblt)))
              (match v ((bvc b v') (bbltc (match b (b0 false) (b1 true)) (bblast_const v' (mp_add n (~ 1)))))
                       (default (fail bblt)))))
              
(declare bv_bbl_const (! n mpz
                      (! f bblt
                      (! v bv
		      ;;(! s ((^ (bv_len v) n)
                      (! c (^ (bblast_const v (mp_add n (~ 1))) f)
                           (bblast_term n (a_bv n v) f)))))))

; bit blast  variable
(program bblast_var ((x var_bv) (n mpz)) bblt
  (mp_ifneg n bbltn 
              (bbltc (bitof x n) (bblast_var x (mp_add n (~ 1))))))

(declare bv_bbl_var (! n mpz
                    (! x var_bv
                    (! f bblt                    
                    (! c (^ (bblast_var x (mp_add n (~ 1))) f)
                         (bblast_term n (a_var_bv n x) f))))))

; bit blast bvand
;; (program bblast_bvand ((x bblt) (y bblt) (n mpz)) bblt
;;   (match x
;;   	(bbltn (match y (bbltn bbltn) (default (fail bblt))))
;; 	((bbltc xn x') (match y (bbltn (fail bblt))
;; 			        ((bbltc yn y') (bbltc (and xn yn) (bblast_bvand x' y' (mp_add n (~ 1)))))))))

(program bblast_bvand ((x bblt) (y bblt)) bblt
  (match x 
    (bbltn (match y (bbltn bbltn) (default (fail bblt))))
    ((bbltc bx x') (match y 
                      (bbltn (fail bblt))
                      ((bbltc by y') (bbltc (and bx by) (bblast_bvand x' y')))))))
				
				
(declare bv_bbl_bvand (! n mpz
                      (! x (term (BitVec n))
		      (! y (term (BitVec n))
		      (! xb bblt
		      (! yb bblt
		      (! rb bblt
		      (! xbb (bblast_term n x xb)
		      (! ybb (bblast_term n y yb)
                      (! c (^ (bblast_bvand xb yb ) rb)
                           (bblast_term n (bvand n x y) rb)))))))))))
			 
; bit blast  x = y
;  for x,y of size n, it will return a conjuction (x.{n-1} = y.{n-1} ^ ( ... ^ (x.0 = y.0 ^ true)))
(program bblast_eq ((x bblt) (y bblt)) formula
  (match x 
    (bbltn (match y (bbltn true) (default (fail formula))))
    ((bbltc fx x') (match y 
                      (bbltn (fail formula))
                      ((bbltc fy y') (and (iff fx fy) (bblast_eq x' y')))))))

(declare bv_bbl_eq
	 (! n mpz
	 (! x (term (BitVec n))
         (! y (term (BitVec n))
         (! bx bblt
         (! by bblt
         (! f formula
         (! bbx (bblast_term n x bx)
         (! bby (bblast_term n y by)
         (! c (^ (bblast_eq bx by) f)
            (th_holds (impl (= (BitVec n) x y) f))))))))))))


; rewrite rule :
; x + y = y + x
(declare bvadd_symm
	 (! n mpz
	 (! x (term (BitVec n))
	 (! y (term (BitVec n))
	    (th_holds (= (BitVec n) (bvadd _ x y) (bvadd _ y x)))))))
	    
;; (declare bvcrazy_rewrite
;; 	 (! n mpz
;; 	 (! x (term (BitVec n))
;; 	 (! y (term (BitVec n))
;; 	 (! xn bv_poly
;; 	 (! yn bv_poly
;; 	 (! hxn (bv_normalizes x xn)
;; 	 (! hyn (bv_normalizes y yn)
;; 	 (! s (^ (rewrite_scc xn yn) true)
;; 	 (! u (! x (term (BitVec n)) (holds cln))
;; 	     (holds cln)))))))))))
	 
;; 	    (th_holds (= (BitVec n) (bvadd x y) (bvadd y x)))))))

	    
	    
; necessary? 
;; (program calc_bvand ((a bv) (b bv)) bv
;;   (match a
;;     (bvn (match b (bvn bvn) (default (fail bv))))
;;     ((bvc ba a') (match b
;;                       ((bvc bb b') (bvc (match ba (b0 b0) (b1 bb)) (calc_bvand a' b')))
;;                       (default (fail bv))))))

;; ; rewrite rule (w constants) :
;; ; a & b = c    
;; (declare bvand_const (! c bv
;; 		     (! a bv
;;                      (! b bv
;;                      (! u (^ (calc_bvand a b) c)
;;                         (th_holds (= BitVec (bvand (a_bv a) (a_bv b)) (a_bv c))))))))


; bit-blasting connections

(declare intro_assump_t
	 (! f formula
	 (! v var
	 (! C clause
	 (! h (th_holds f)
	 (! a (atom v f)
	 (! u (! unit (holds (clc (pos v) cln))
	      	 (holds C))
	 (holds C))))))))

(declare intro_assump_f
	 (! f formula
	 (! v var
	 (! C clause
	 (! h (th_holds (not f))
	 (! a (atom v f)
	 (! u (! unit (holds (clc (neg v) cln))
	      	 (holds C))
	 (holds C))))))))
