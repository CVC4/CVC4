; helper stuff
(program mpz_sub ((x mpz) (y mpz)) mpz
	 (mp_add x (mp_mul (~1) y)))

(program mpz_eq ((x mpz) (y mpz)) formula
    (mp_ifzero (mpz_sub x y) true false))
  
; "bitvec" is a term of type "sort"
; (declare BitVec sort)
(declare BitVec (!n mpz sort))

; bit type
(declare bit type)
(declare b0 bit)
(declare b1 bit)

; bit vector type used for constants
(declare bv type)
(declare bvn bv)
(declare bvc (! b bit (! v bv bv)))

; calculate the length of a bitvector
(program bv_len ((v bv)) mpz 
  (match v
    (bvn 0)
    ((bvc b v') (mp_add (bv_len v') 1))))

; a bv constant term
(declare a_bv
	 (! n mpz
	 (! v bv
	    (term (BitVec n)))))
	 

; a bv variable
(declare var_bv type)
; a bv variable term
(declare a_var_bv
	 (! n mpz
	 (! v var_bv
	    (term (BitVec n)))))

; bit vector binary operators
(define bvop2
	(! n mpz
	(! x (term (BitVec n)) 
        (! y (term (BitVec n))
             	   (term (BitVec n))))))

(declare bvand bvop2)
(declare bvor bvop2)
(declare bvor bvop2)
(declare bvxor bvop2)
(declare bvnand bvop2)
(declare bvnor bvop2)
(declare bvxnor bvop2)
(declare bvcomp bvop2)
(declare bvmul bvop2)
(declare bvadd bvop2)
(declare bvsub bvop2)
(declare bvudiv bvop2)
(declare bvurem bvop2)
(declare bvsdiv bvop2)
(declare bvsrem bvop2)
(declare bvsmod bvop2)
(declare bvshl bvop2)
(declare bvlshr bvop2)
(declare bvashr bvop2)
(declare concat bvop2)

; bit vector unary operators
(define bvop1
	(! n mpz
	(! x (term (BitVec n)) 
             	   (term (BitVec n)))))


(declare bvneg bvop1)
(declare bvnot bvop1)
(declare rotate_left  bvop1)
(declare rotate_right bvop1)


; bit vector parametrized operators
;; TODO side conditions for result bitwidth
;; (define bvopp
;; 	(! n mpz
;; 	(! i mpz
;; 	(! x (term (BitVec n)) 
;;               	   (term BitVec))))

(declare concatt
	 (! n mpz
	 (! m mpz
	 (! m' mpz
	 (! t1 (term (BitVec n))
	 (! t2 (term (BitVec m))
	 (! s (^ (mp_add n m) m')
	    (term (BitVec m')))))))))

;; (declare repeat bvopp)
;; (declare zero_extend bvopp)
;; (declare sign_extend bvopp)

;; ; bit vector parametrized operator with 2 arguments
;; (define bvopp2 (! i mpz
;; 	       (! j mpz
;; 	       (! x (term BitVec) 
;;                     (term BitVec)))))
		    
;; (declare extract bvopp2)

;; (define extract
;; 	(! n mpz
;; 	(! i mpz
;; 	(! j mpz
;; 	(! t (term (BitVec n))
;; 	(! m mpz
;; 	(! s (^ (mpz_sub j i) m)
;; 	   (term (BitVec m)))))))))
	   
; bit vector predicates
(define bvpred
	(! n mpz
	(! x (term (BitVec n))
	(! y (term (BitVec n))
	           formula))))
		   
(declare bvult bvpred)
(declare bvule bvpred)
(declare bvugt bvpred)
(declare bvuge bvpred)
(declare bvslt bvpred)
(declare bvsle bvpred)
(declare bvsgt bvpred)
(declare bvsge bvpred)


; all bit-vector terms are mapped with "bv_term" to:
;  - a simply-typed term of type "var_bv", which is necessary for bit-blasting
;  - a integer size
; (declare bv_term (! x (term BitVec) (! y var_bv (! n mpz type))))

;; (declare decl_bv_term_var (! n mpz    ; must be specified
;;                           (! x var_bv
;;                           (! p (! u (bv_term (a_var_bv x) x n)
;;                                  (holds cln))
;;                              (holds cln)))))

;; (declare decl_bv_term_const (! n mpz
;;                             (! v bv
;;                             (! s (^ (bv_len v) n)
;;                             (! p (! w var_bv
;;                                  (! u (bv_term (a_bv v) w n)
;;                                    (holds cln)))
;; 			      (holds cln))))))


; other terms here?


; bit blasted terms as list of formulas
(declare bblt type)
(declare bbltn bblt)
(declare bbltc (! f formula (! v bblt bblt)))

; calculate the length of a bit-blasted term
(program bblt_len ((v bblt)) mpz 
  (match v
    (bbltn 0)
    ((bbltc b v') (mp_add (bblt_len v') 1))))


; (bblast_term x y) means term y corresponds to bit level interpretation x
(declare bblast_term
	 (! n mpz
	 (! x (term (BitVec n))
	 (! y bblt
	    type))))

(declare decl_bblast
	 (! n mpz
	 (! b bblt
	 (! t (term (BitVec n))
	 (! bb (bblast_term n t b)
	 (! s (^ (bblt_len b) n)
	 (! u (! v (bblast_term n t b) (holds cln))
		   (holds cln))))))))


; a predicate to represent the n^th bit of a bitvector term
(declare bitof
	 (! x var_bv
	 (! n mpz formula)))

; bit blast  constant
(program bblast_const ((v bv) (n mpz)) bblt
  (mp_ifneg n (match v (bvn bbltn) 
                       (default (fail bblt)))
              (match v ((bvc b v') (bbltc (match b (b0 false) (b1 true)) (bblast_const v' (mp_add n (~ 1)))))
                       (default (fail bblt)))))
              
(declare bv_bbl_const (! n mpz
                      (! f bblt
                      (! v bv
		      ;;(! s ((^ (bv_len v) n)
                      (! c (^ (bblast_const v (mp_add n (~ 1))) f)
                           (bblast_term n (a_bv n v) f)))))))

; bit blast  variable
(program bblast_var ((x var_bv) (n mpz)) bblt
  (mp_ifneg n bbltn 
              (bbltc (bitof x n) (bblast_var x (mp_add n (~ 1))))))

(declare bv_bbl_var (! n mpz
                    (! x var_bv
                    (! f bblt                    
                    (! c (^ (bblast_var x (mp_add n (~ 1))) f)
                         (bblast_term n (a_var_bv n x) f))))))

(program bblast_bvand ((x bblt) (y bblt)) bblt
  (match x 
    (bbltn (match y (bbltn bbltn) (default (fail bblt))))
    ((bbltc bx x') (match y 
                      (bbltn (fail bblt))
                      ((bbltc by y') (bbltc (and bx by) (bblast_bvand x' y')))))))
				
				
(declare bv_bbl_bvand (! n mpz
                      (! x (term (BitVec n))
		      (! y (term (BitVec n))
		      (! xb bblt
		      (! yb bblt
		      (! rb bblt
		      (! xbb (bblast_term n x xb)
		      (! ybb (bblast_term n y yb)
                      (! c (^ (bblast_bvand xb yb ) rb)
                           (bblast_term n (bvand n x y) rb)))))))))))

(program bblast_bvnot ((x bblt)) bblt
  (match x 
    (bbltn bbltn) 
    ((bbltc bx x') (bbltc (not bx) (bblast_bvnot x')))))
				
				
(declare bv_bbl_bvnot (! n mpz
                      (! x (term (BitVec n))
		      (! xb bblt
		      (! rb bblt
		      (! xbb (bblast_term n x xb)
                      (! c (^ (bblast_bvnot xb ) rb)
                           (bblast_term n (bvnot n x) rb))))))))
			   
(program bblast_bvor ((x bblt) (y bblt)) bblt
  (match x 
    (bbltn (match y (bbltn bbltn) (default (fail bblt))))
    ((bbltc bx x') (match y 
                      (bbltn (fail bblt))
                      ((bbltc by y') (bbltc (or bx by) (bblast_bvor x' y')))))))
				
				
(declare bv_bbl_bvor (! n mpz
                      (! x (term (BitVec n))
		      (! y (term (BitVec n))
		      (! xb bblt
		      (! yb bblt
		      (! rb bblt
		      (! xbb (bblast_term n x xb)
		      (! ybb (bblast_term n y yb)
                      (! c (^ (bblast_bvor xb yb ) rb)
                           (bblast_term n (bvor n x y) rb)))))))))))

(program bblast_bvxor ((x bblt) (y bblt)) bblt
  (match x 
    (bbltn (match y (bbltn bbltn) (default (fail bblt))))
    ((bbltc bx x') (match y 
                      (bbltn (fail bblt))
                      ((bbltc by y') (bbltc (xor bx by) (bblast_bvxor x' y')))))))
				
				
(declare bv_bbl_bvxor (! n mpz
                      (! x (term (BitVec n))
		      (! y (term (BitVec n))
		      (! xb bblt
		      (! yb bblt
		      (! rb bblt
		      (! xbb (bblast_term n x xb)
		      (! ybb (bblast_term n y yb)
                      (! c (^ (bblast_bvxor xb yb ) rb)
                           (bblast_term n (bvxor n x y) rb)))))))))))

			   
;; return the carry bit after adding x y			   
;; FIXME: not the most efficient thing in the world
(program bblast_bvadd_carry ((a bblt) (b bblt) (carry formula)) formula
(match a
  ( bbltn (match b (bbltn carry) (default (fail formula))))
  ((bbltc ai a') (match b
  	     	   (bbltn (fail formula))
	 	   ((bbltc bi b') (or (and ai bi) (and (xor ai bi) (bblast_bvadd_carry a' b' carry))))))))

;; ripple carry adder where carry is the initial carry bit		   
(program bblast_bvadd ((a bblt) (b bblt) (carry formula)) bblt
(match a
  ( bbltn (match b (bbltn bbltn) (default (fail bblt))))
  ((bbltc ai a') (match b
  	     	   (bbltn (fail bblt))
	 	   ((bbltc bi b') (bbltc (xor ai (xor bi (bblast_bvadd_carry a' b' carry)))
				  	 (bblast_bvadd a' b' carry)))))))
				
				
(declare bv_bbl_bvadd (! n mpz
                      (! x (term (BitVec n))
		      (! y (term (BitVec n))
		      (! xb bblt
		      (! yb bblt
		      (! rb bblt
		      (! xbb (bblast_term n x xb)
		      (! ybb (bblast_term n y yb)
                      (! c (^ (bblast_bvadd xb yb false) rb)
                           (bblast_term n (bvadd n x y) rb)))))))))))

;; shift add multiplier

(program reverse_help ((x bblt) (acc bblt)) bblt
(match x
       (bbltn acc)
       ((bbltc xi x') (reverse_help x' (bbltc xi acc)))))


(program reverseb ((x bblt)) bblt
	 (reverse_help x bbltn))

(program concat ((a bblt) (b bblt)) bblt
  (match a (bbltn b)
  	   ((bbltc ai a') (bbltc ai (concat a' b)))))

	   
(program top_k_bits ((a bblt) (k mpz)) bblt
  (mp_ifzero k bbltn
  	     (match a (bbltn (fail bblt))
	     	      ((bbltc ai a') (bbltc ai (top_k_bits a' (mpz_sub k 1)))))))

(program bottom_k_bits ((a bblt) (k mpz)) bblt
 (reverseb (top_k_bits (reverseb a) k)))

;; assumes the least signigicant bit is at the beginning of the list 
(program k_bit ((a bblt) (k mpz)) formula
(mp_ifneg k (fail formula)
(match a (bbltn (fail formula))
         ((bbltc ai a') (mp_ifzero k ai (k_bit a' (mpz_sub k 1)))))))

(program and_with_bit ((a bblt) (bt formula)) bblt
(match a (bbltn bbltn)
         ((bbltc ai a') (bbltc (and bt ai) (and_with_bit a' bt)))))
	 
;; a is going to be the current result
;; carry is going to be false initially
;; b is the and of a and b[k]
;; res is going to be bbltn initially
(program mult_step_k_h ((a bblt) (b bblt) (res bblt) (carry formula) (k mpz)) bblt
(match a
  (bbltn (match b (bbltn res) (default (fail bblt))))
  ((bbltc ai a')
    (match b (bbltn (fail bblt))
             ((bbltc bi b')
	     (mp_ifneg (mpz_sub k 1)
	     	         (let carry_out (or (and ai bi) (and (xor ai bi) carry))
			 (let curr (xor (xor ai bi) carry)
			    (mult_step_k_h a' b' (bbltc curr res) carry_out (mpz_sub k 1))))
			 (mult_step_k_h a' b (bbltc ai res) carry (mpz_sub k 1))
))))))

;; assumes that a, b and res have already been reversed
(program mult_step ((a bblt) (b bblt) (res bblt) (n mpz) (k mpz)) bblt
(let k' (mpz_sub n k )
(let ak (top_k_bits a k')
(let b' (and_with_bit ak (k_bit b k))
 (mp_ifzero (mpz_sub k' 1)
   (mult_step_k_h res b' bbltn false k)	
   (let res' (mult_step_k_h res b' bbltn false k)
   (mult_step a b (reverseb res') n (mp_add k 1))))))))


(program bblast_bvmul ((a bblt) (b bblt) (n mpz)) bblt
(let ar (reverseb a) ;; reverse a and b so that we can build the circuit 
(let br (reverseb b) ;; from the least significant bit up
(let res (and_with_bit ar (k_bit br 0))
     (mult_step ar br res n 1)))))
     
(declare bv_bbl_bvmul (! n mpz
                      (! x (term (BitVec n))
		      (! y (term (BitVec n))
		      (! xb bblt
		      (! yb bblt
		      (! rb bblt
		      (! xbb (bblast_term n x xb)
		      (! ybb (bblast_term n y yb)
                      (! c (^ (bblast_bvmul xb yb n) rb)
                           (bblast_term n (bvmul n x y) rb)))))))))))
			   
; bit blast  x = y
;  for x,y of size n, it will return a conjuction (x.{n-1} = y.{n-1} ^ ( ... ^ (x.0 = y.0 ^ true)))
(program bblast_eq ((x bblt) (y bblt)) formula
  (match x 
    (bbltn (match y (bbltn true) (default (fail formula))))
    ((bbltc fx x') (match y 
                      (bbltn (fail formula))
                      ((bbltc fy y') (and (iff fx fy) (bblast_eq x' y')))))))

(declare bv_bbl_eq
	 (! n mpz
	 (! x (term (BitVec n))
         (! y (term (BitVec n))
         (! bx bblt
         (! by bblt
         (! f formula
         (! bbx (bblast_term n x bx)
         (! bby (bblast_term n y by)
         (! c (^ (bblast_eq bx by) f)
            (th_holds (impl (= (BitVec n) x y) f))))))))))))

			 
	    
(program bblast_bvult ((x bblt) (y bblt) (n mpz)) formula
(match x
  ( bbltn (fail formula))
  ((bbltc xi x') (match y
  	     	   (bbltn (fail formula))
	 	   ((bbltc yi y') (mp_ifzero n
		                    (and (not xi) yi)
				    (or (and (iff xi yi) (bblast_bvult x' y' (mp_add n (~1)))) (and (not xi) yi))))))))

(declare bv_bbl_bvult
	 (! n mpz
	 (! x (term (BitVec n))
         (! y (term (BitVec n))
         (! bx bblt
         (! by bblt
         (! f formula
         (! bbx (bblast_term n x bx)
         (! bby (bblast_term n y by)
         (! c (^ (bblast_bvult bx by (mp_add n (~1))) f)
            (th_holds (impl (bvult n x y) f))))))))))))

	    

	    
; rewrite rule :
; x + y = y + x
(declare bvadd_symm
	 (! n mpz
	 (! x (term (BitVec n))
	 (! y (term (BitVec n))
	    (th_holds (= (BitVec n) (bvadd _ x y) (bvadd _ y x)))))))
	    
;; (declare bvcrazy_rewrite
;; 	 (! n mpz
;; 	 (! x (term (BitVec n))
;; 	 (! y (term (BitVec n))
;; 	 (! xn bv_poly
;; 	 (! yn bv_poly
;; 	 (! hxn (bv_normalizes x xn)
;; 	 (! hyn (bv_normalizes y yn)
;; 	 (! s (^ (rewrite_scc xn yn) true)
;; 	 (! u (! x (term (BitVec n)) (holds cln))
;; 	     (holds cln)))))))))))
	 
;; 	    (th_holds (= (BitVec n) (bvadd x y) (bvadd y x)))))))

	    
	    
; necessary? 
;; (program calc_bvand ((a bv) (b bv)) bv
;;   (match a
;;     (bvn (match b (bvn bvn) (default (fail bv))))
;;     ((bvc ba a') (match b
;;                       ((bvc bb b') (bvc (match ba (b0 b0) (b1 bb)) (calc_bvand a' b')))
;;                       (default (fail bv))))))

;; ; rewrite rule (w constants) :
;; ; a & b = c    
;; (declare bvand_const (! c bv
;; 		     (! a bv
;;                      (! b bv
;;                      (! u (^ (calc_bvand a b) c)
;;                         (th_holds (= BitVec (bvand (a_bv a) (a_bv b)) (a_bv c))))))))


; bit-blasting connections

(declare intro_assump_t
	 (! f formula
	 (! v var
	 (! C clause
	 (! h (th_holds f)
	 (! a (atom v f)
	 (! u (! unit (holds (clc (pos v) cln))
	      	 (holds C))
	 (holds C))))))))

(declare intro_assump_f
	 (! f formula
	 (! v var
	 (! C clause
	 (! h (th_holds (not f))
	 (! a (atom v f)
	 (! u (! unit (holds (clc (neg v) cln))
	      	 (holds C))
	 (holds C))))))))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;; BitVector Rewrite rules
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; making constant bit-vectors	 
(program mk_ones ((n mpz)) bv
	(mp_ifzero n bvn (bvc b1 (mk_ones (mpz_sub n 1)))))

(program mk_zero ((n mpz)) bv
	(mp_ifzero n bvn (bvc b0 (mk_ones (mpz_sub n 1)))))


	
;; (bvxnor a b) => (bvnot (bvxor a b))
;; (declare bvxnor_elim
;; 	 (! n mpz
;; 	 (! a (term (BitVec n))
;; 	 (! b (term (BitVec n))
;; 	 (! a' (term (BitVec n))
;; 	 (! b' (term (BitVec n))
;; 	 (! rwa (rw_term _ a a')
;; 	 (! rwb (rw_term _ b b')
;; 	 (rw_term n (bvxnor _ a b)
;; 	 	  (bvnot _ (bvxor _ a' b')))))))))))



;; ;; (bvxor a 0) => a
;; (declare bvxor_zero
;; 	 (! n mpz
;; 	 (! zero_bits bv
;; 	 (! sc (^ (mk_zero n)  zero_bits)
;; 	 (! a (term (BitVec n))
;; 	 (! b (term (BitVec n))
;; 	 (! a' (term (BitVec n))
;; 	 (! rwa (rw_term _  a a')
;; 	 (! rwb (rw_term _ b (a_bv _ zero_bits))
;; 	 (rw_term _  (bvxor _ a b)
;; 	 	  a'))))))))))
		  
;; ;; (bvxor a 11) => (bvnot a)
;; (declare bvxor_one
;; 	 (! n mpz
;; 	 (! one_bits bv
;; 	 (! sc (^ (mk_ones n)  one_bits)
;; 	 (! a (term (BitVec n))
;; 	 (! b (term (BitVec n))
;; 	 (! a' (term (BitVec n))
;; 	 (! rwa (rw_term _  a a')
;; 	 (! rwb (rw_term _  b (a_bv _ one_bits))
;; 	 (rw_term _ (bvxor _ a b)
;; 	 	  (bvnot _ a')))))))))))

		  
;; ;; (bvnot (bvnot a)) => a
;; (declare bvnot_idemp
;; 	 (! n mpz
;; 	 (! a (term (BitVec n))
;; 	 (! a' (term (BitVec n))
;; 	 (! rwa (rw_term _  a a')
;; 	 (rw_term _ (bvnot _ (bvnot _ a))
;; 	 	  a'))))))

