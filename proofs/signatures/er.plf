; Depends on sat.plf

; This file exists to support the **Definition** rule in the paper:
;  "Extended Resolution Simulates DRAT"
; which can be found at http://www.cs.utexas.edu/~marijn/publications/ijcar18.pdf
;
; The core idea of extended resolution is that given **any** formula f
; involving the variables from some SAT problem, one can introduce the
; constraint
;
;    new <=> f
;
; without changing satisfiability, where "new" is a fresh variable.
;
; The paper uses the extension rule:
;
;    new <=> old v (~l_1 ^ ~l_2 ^ ... ^ ~l_n)
;
; which translates into the clauses:
;
;                      new v l_1 v l_2 v ... v l_n
;                      new v ~old
;     for each i <= n: l_i v ~new v old
;
; This translation could be proven using natural deduction, but instead we make
; it an axiom for faster checking. It would be cool to make is a theorem, not
; an axiom!

(declare cnfc_unroll_towards_bottom
         (! first clause
            (! rest cnf
               (! pf (cnf_holds (cnfc first rest))
                  (! rest_of_pf (! r1 (holds first) (! r2 (cnf_holds rest) (holds cln)))
                    (holds cln))))))

; Takes a `list` of literals and a clause, `suffix`, adds the suffix to each
; literal and returns a list of clauses as a `cnf`.
(program clause_add_suffix_all ((list clause) (suffix clause)) cnf
         (match list
                (cln cnfn)
                ((clc l rest) (cnfc (clc l suffix)
                                    (clause_add_suffix_all rest suffix)))))

; A definition witness value for:
;              new <=> old v (~others_1 ^ ~others_2 ^ ... ^ ~others_n)
; It witnesses the fact that new was fresh when it was defined by the above.
; Thus it witnesses that the above is TAUT.
(declare rat_elimination_def (! new var (! old lit (! others clause type))))

; Given `old` and `others`, this takes a continuation which expects
;      1. a fresh variable `new`
;      2. a definition witness value for:
;              new <=> old v (~others_1 ^ ~others_2 ^ ... ^ ~others_n)
;
; That definition witness value can be clausified using the rule below.
;
; There need to be two different rules because the side-condition for
; clausification needs access to the new variable, which doesn't exist except
; inside the continuation, which is out-of-scope for any side-condition
; associated with this rule.
(declare decl_rat_elimination_def
         (! old lit
            (! others clause ; List of vars
               (! pf_continuation (! new var (! def (rat_elimination_def new old others)
                                           (holds cln)))
                  (holds cln)))))

; This translates a definition witness value for the def:
;
;    new <=> old v (~l_1 ^ ~l_2 ^ ... ^ ~l_n)
;
; into the clauses:
;
;                      new v l_1 v l_2 v ... v l_n
;                      new v ~old
;     for each i <= n: l_i v ~new v old              (encoded as (cnf_holds ...))
(declare clausify_rat_elimination_def
         (! new var ; elide
         (! old lit ; elide
         (! others clause ; elide
         ; Given a definition { new <-> old v (~l_1 ^ ~l_2 ^ ... ^ ~l_n) }
         (! def (rat_elimination_def new old others)
         (! negOld lit ; elide
         (! mkNegOld (^ (lit_flip old) negOld)
         (! provenCnf cnf ; elide
         (! mkProvenCnf (^ (clause_add_suffix_all
                             others
                             (clc (neg new) (clc old cln))) provenCnf)
         ; If you can prove bottom from its clausal representation
         (! pf_continuation
            ; new v l_1 v l_2 v ... v l_n
            (! pf_c1 (holds (clc (pos new) others))
               ; new v ~old
               (! pf_c2 (holds (clc (pos new) (clc negOld cln)))
                  ; for each i <= n: l_i v ~new v old
                  (! pf_cs (cnf_holds provenCnf)
                     (holds cln))))
         ; Then you've proven bottom
         (holds cln)))))))))))

