/********************                                                        */
/*! \file sygus_enumerator.h
 ** \verbatim
 ** Top contributors (to current version):
 **   Andrew Reynolds
 ** This file is part of the CVC4 project.
 ** Copyright (c) 2009-2018 by the authors listed in the file AUTHORS
 ** in the top-level source directory) and their institutional affiliations.
 ** All rights reserved.  See the file COPYING in the top-level source
 ** directory for licensing information.\endverbatim
 **
 ** \brief sygus_enumerator
 **/

#include "cvc4_private.h"

#ifndef __CVC4__THEORY__QUANTIFIERS__SYGUS_ENUMERATOR_H
#define __CVC4__THEORY__QUANTIFIERS__SYGUS_ENUMERATOR_H

#include <map>
#include <unordered_set>
#include "expr/node.h"
#include "expr/type_node.h"
#include "theory/quantifiers/sygus/synth_conjecture.h"
#include "theory/quantifiers/sygus/term_database_sygus.h"

namespace CVC4 {
namespace theory {
namespace quantifiers {

/** SygusEnumerator
 *
 */
class SygusEnumerator : public EnumValGenerator
{
 public:
  SygusEnumerator(TermDbSygus* tds);
  ~SygusEnumerator() {}
  /** initialize this class with enumerator e */
  void initialize(Node e) override;
  /** Inform this generator that abstract value v was enumerated. */
  void addValue(Node v) override;
  /** Get the next concrete value generated by this class. */
  Node getNext() override;

 private:
  /** pointer to term database sygus */
  TermDbSygus* d_tds;
  /** Term cache
   *
   * This stores a list of
   */
  class TermCache
  {
   public:
    TermCache();
    /** initialize this cache */
    void initialize(TypeNode tn, TermDbSygus* tds);
    /** get num constructor classes */
    unsigned getNumConstructorClasses() const;
    /** get constructor class */
    void getConstructorClass(unsigned i, std::vector<unsigned>& cclass) const;
    /** get types for constructor class */
    void getTypesForConstructorClass(unsigned i,
                                     std::vector<TypeNode>& types) const;
    /** get child for constructor */
    void getChildIndicesForConstructor(unsigned i,
                                       std::vector<unsigned>& cindices) const;

    /**
     * Add sygus term n to this cache, return true if the term was unique based
     * on the redundancy criteria used by this class.
     */
    bool addTerm(Node n);
    /**
     * Indicate to this cache that we are finished enumerating terms of the
     * current size
     */
    void pushEnumSizeIndex();
    /** Get the current size of terms that we are enumerating */
    unsigned getEnumSize() const;
    /** get the index at which size s terms start */
    unsigned getIndexForSize(unsigned s) const;
    /** get the index^th term successfully added to this cache */
    Node getTerm(unsigned index) const;
    /** get the number of terms */
    unsigned getNumTerms() const;

   private:
    /** the sygus type of terms in this cache */
    TypeNode d_tn;
    /** pointer to term database sygus */
    TermDbSygus* d_tds;
    //-------------------------static information about type
    /** number of constructor classes */
    unsigned d_numConClasses;
    /** constructor classes */
    std::map<unsigned, std::vector<unsigned> > d_ccToCons;
    /** maps constructor classes to children types */
    std::map<unsigned, std::vector<TypeNode> > d_ccToTypes;
    /** constructor to indices */
    std::map<unsigned, std::vector<unsigned> > d_cToCIndices;
    //-------------------------end static information about type

    /** the list of sygus terms we have enumerated */
    std::vector<Node> d_terms;
    /** the set of builtin terms corresponding to the above list */
    std::unordered_set<Node, NodeHashFunction> d_bterms;
    /** the index of first term of each size, if it exists */
    std::map<unsigned, unsigned> d_lastSizeIndex;
    /** the maximum size of terms we have stored in this cache so far */
    unsigned d_sizeEnum;
  };
  /** above cache for each sygus type */
  std::map<TypeNode, TermCache> d_tcache;
  /** initialize term cache for type tn */
  void initializeTermCache(TypeNode tn);

  class TermEnum
  {
   public:
    TermEnum();
    virtual ~TermEnum() {}
    /** get the current size of terms we are enumerating */
    unsigned getCurrentSize();
    /** get the current term of the enumerator */
    virtual Node getCurrent() = 0;
    /** increment the enumerator */
    virtual bool increment() = 0;

   protected:
    /** pointer to the sygus enumerator class */
    SygusEnumerator* d_se;
    /** the (sygus) type of terms we are enumerating */
    TypeNode d_tn;
    /** the current size of terms we are enumerating */
    unsigned d_currSize;
  };
  class TermEnumMaster;
  class TermEnumSlave : public TermEnum
  {
   public:
    TermEnumSlave();
    /** initialize this enumerator */
    bool initialize(SygusEnumerator* se,
                    TypeNode tn,
                    unsigned sizeLim,
                    bool sizeExact);
    /** get the current term of the enumerator */
    Node getCurrent() override;
    /** increment the enumerator */
    bool increment() override;

   private:
    //------------------------------------------- for non-master enumerators
    /** the size limit */
    unsigned d_sizeLim;
    /** the current index in the term cache we are considering */
    unsigned d_index;
    /** the end index in the term cache */
    unsigned d_indexNextEnd;
    /** has next index end */
    bool d_hasIndexNextEnd;
    /** master enum */
    TermEnumMaster* d_master;
    /** validate index */
    bool validateIndex();
    /** validate next end index */
    void validateIndexNextEnd();
    /** increment the enumerator */
    bool incrementInternal();
    //------------------------------------------- end for non-master enumerators
  };
  class TermEnumMaster : public TermEnum
  {
   public:
    TermEnumMaster();
    /** initialize this enumerator */
    bool initialize(SygusEnumerator* se, TypeNode tn);
    /** get the current term of the enumerator */
    Node getCurrent() override;
    /** increment the enumerator */
    bool increment() override;

   private:
    //----------------------------------------------- for master enumerators
    /** are we currently inside a increment() call? */
    bool d_isIncrementing;
    /** the next constructor class we are using */
    unsigned d_consClassNum;
    /** the constructors in the current constructor class */
    std::vector<unsigned> d_ccCons;
    /** the types of the current constructor class */
    std::vector<TypeNode> d_ccTypes;
    /** 1 + the current index in the above vector we are considering */
    unsigned d_consNum;
    /** the child enumerators for this enumerator */
    std::map<unsigned, TermEnumSlave> d_children;
    /** the current term */
    Node d_currTerm;
    /** the current sum of child sizes */
    unsigned d_currChildSize;
    /** children valid */
    unsigned d_childrenValid;
    /** initialize children */
    bool initializeChildren();
    /** initialize child */
    bool initializeChild(unsigned i);
    /** increment internal */
    bool incrementInternal();
    //----------------------------------------------- end for master enumerators
  };
  /** the master enumerator for each type */
  std::map<TypeNode, TermEnumMaster> d_masterEnum;
  /** the top-level type */
  TypeNode d_etype;
  /** pointer to the top-level enumerator */
  TermEnumMaster* d_tlEnum;
  /** get master enumerator for type */
  TermEnumMaster* getMasterEnumForType(TypeNode tn);
};

}  // namespace quantifiers
}  // namespace theory
}  // namespace CVC4

#endif /* __CVC4__THEORY__QUANTIFIERS__SYGUS_ENUMERATOR_H */
