/*********************                                                        */
/*! \file ho_trigger.h
 ** \verbatim
 ** Top contributors (to current version):
 **   Andrew Reynolds
 ** This file is part of the CVC4 project.
 ** Copyright (c) 2009-2017 by the authors listed in the file AUTHORS
 ** in the top-level source directory) and their institutional affiliations.
 ** All rights reserved.  See the file COPYING in the top-level source
 ** directory for licensing information.\endverbatim
 **
 ** \brief higher-order trigger class
 **/

#include "cvc4_private.h"

#ifndef __CVC4__THEORY__QUANTIFIERS__HO_TRIGGER_H
#define __CVC4__THEORY__QUANTIFIERS__HO_TRIGGER_H

#include <map>

#include "expr/node.h"
#include "theory/quantifiers/inst_match.h"
#include "options/quantifiers_options.h"
#include "theory/quantifiers/trigger.h"

namespace CVC4 {
namespace theory {

class QuantifiersEngine;

namespace inst {

class Trigger;

/** HigherOrder trigger 
*
* This extends the trigger class with techniques that post-process instantiations, specified by
* InstMatch objects according to higher-order preunification (also called Huet's algorithm). For examples,
* see description in the cpp.
*
* Its main function is sendInstantiation(...), which is called by its underlying IMGenerator generates
* an instantiation by standard E-matching. We enumerate a candidate 
*/
class HigherOrderTrigger : public Trigger {
  friend class Trigger;
private:
  HigherOrderTrigger( QuantifiersEngine* qe, Node q, std::vector< Node >& nodes, 
                      std::map< Node, std::vector< Node > >& ho_apps );
  virtual ~HigherOrderTrigger();
public:
  /** collect all top-level HO_APPLY terms in n whose head is a variable in quantified formula q, store in apps */
  static void collectHoVarApplyTerms( Node q, TNode n, std::map< Node, std::vector< Node > >& apps );
  /** collect all top-level HO_APPLY terms in terms ns whose head is a variable in quantified formula q, store in apps */
  static void collectHoVarApplyTerms( Node q, std::vector< Node >& ns, std::map< Node, std::vector< Node > >& apps );  
  /** add all available instantiations exhaustively, extends Trigger::addInstantiations for this trigger */
  virtual int addInstantiations( InstMatch& baseMatch );
protected: 
  /** map from variable functions to their applications in the quantifier d_f (member of Trigger) */
  std::map< Node, std::vector< Node > > d_ho_var_apps;
  /** list of all variable functions that are applied in d_f */
  std::vector< Node > d_ho_var_list;
  /** bound variables, bound variable list for each ho variable, used for constructing lambda terms in instantiations */
  std::map< TNode, std::vector< Node > > d_ho_var_bvs;
  std::map< TNode, Node > d_ho_var_bvl;
  /** the set of types of ho variables */
  std::vector< TypeNode > d_ho_var_types;
  /** add higher-order type predicate lemmas 
  * This predicate is used to force certain functions f of type tn to appear as first-class representatives in the
  * quantifier-free UF solver. For a typical use case, we call getHoTypeMatchPredicate which returns a fresh 
  * predicate P of type (tn -> Bool). Then, we add P( f ) as a lemma.  
  * TODO: we may eliminate this depending on how github issue #1115 is resolved.
  */
  int addHoTypeMatchPredicateLemmas();
  /** send instantiation 
  * Sends an instantiation that is equivalent to m via d_quantEngine->addInstantiation(...).
  *
  * We may modify m based on imitations and projections (Huet's algorithm)
  * if m was generated by matching ground terms to function applications
  * with variable heads. For examples, see ho_trigger.cpp
  */
  virtual bool sendInstantiation( InstMatch& m );
private:
  //-------------------- current information about the match
  /** map from variable position to the lambda we generated */
  std::map< unsigned, std::vector< Node > > d_lchildren;
  /** map from variable position to the representative variable position.
  * Used when two variables are mapped to equal terms, for an example, see second example in cpp.
  */
  std::map< unsigned, std::map< unsigned, unsigned > > d_arg_to_arg_rep;
  /** map from representative variable positions to their equivalence class */
  std::map< unsigned, std::map< unsigned, std::vector< Node > > > d_arg_vector;
  //-------------------- end current information about the match
  /** higher-order pattern unification algorithm 
  * Sends an instantiation that is equivalent to m via d_quantEngine->addInstantiation(...).
  * This is a helper function of sendInstantiation( m ) above.
  *
  * var_index is the index of the variable in m that are we currently processing
  *   i.e. we are processing the var_index^{th} higher-order variable.
  */
  bool sendInstantiation( InstMatch& m, unsigned var_index );
  /** higher-order pattern unification algorithm 
  * Sends an instantiation that is equivalent to m via d_quantEngine->addInstantiation(...).
  * This is a helper function of sendInstantiation( m, var_index ) above.
  *
  * var_index is the index of the variable in m that are we currently processing
  *   i.e. we are processing the var_index^{th} higher-order variable.
  * vnum maps var_index to the actual variable number in m
  * arg_index is the argument of the lambda term we are currently considering
  * lbvl is the bound variable list associated with the term in m we are currently modifying
  * arg_changed is whether we have modified m
  */
  bool sendInstantiationArg( InstMatch& m, unsigned var_index, unsigned vnum, unsigned arg_index,
                             Node lbvl, bool arg_changed );
};

}/* CVC4::theory::inst namespace */
}/* CVC4::theory namespace */
}/* CVC4 namespace */

#endif /* __CVC4__THEORY__QUANTIFIERS__HO_TRIGGER_H */
